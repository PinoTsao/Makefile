### 此笔记用来记录各种小问题的分析 ###

Q1. arch/x86 目录下编译流程分析
Makefile
$(vmlinux-dirs): prepare scripts
         $(Q)$(MAKE) $(build)=$@
----->
arch/x86: xxx yyy
         make -f $(srctree)/scripts/Makefile.build obj=arch/x86

scripts/Makefile.build
src=obj=kbuuild-dir = arch/x86
kbuild-file = arch/x86/Kbuild

Makefile.lib
arch/x86/Kbuild 中定义的 obj-y 都是目录(arch/x86 下的子目录), obj-y=entry/ realmode/ kernel/ mm/ crypto/ platform/ net/ 等等
经过处理:
obj-y := $(patsubst %/, %/built-in.o, $(obj-y)), 将 obj-y 中的目录, 变为 entry/built-in.o kernel/built-in.o mm/built-in.o 等,其余不变
subdir-ym := $(sort $(subdir-y) $(subdir-m)), subdir-ym 的值是 arch/x86下的子目录名, 也即 entry realmode kernel mm 等等
subdir-obj-y := $(filter %/built-in.o, $(obj-y)), subdir-obj-y 的值是所有的 foo/built-in.o
obj-dirs := $(dir $(multi-objs) $(obj-y)), obj-dirs 的值是最初 obj-y 的定义 entry/ realmode/ kernel/ 等等
最后给上面的变量都加上$(obj), 即 arch/x86 作为前缀

回到Makefile.build
__build: $(if $(KBUILD_BUILTIN),$(builtin-target) $(lib-target) $(extra-y)) \
          $(if $(KBUILD_MODULES),$(obj-m) $(modorder-target)) \
          $(subdir-ym) $(always)
--->
__build: arch/x86/built-in.o entry realmode kernel mm [expand from subdir-ym]

# To build objects in subdirs, we need to descend into the directories
$(sort $(subdir-obj-y)): $(subdir-ym) ;
$(subdir-ym):
         $(Q)$(MAKE) $(build)=$@
由此看出, 将对 subdir 进行 recursive 的 build, 直到最底层的文件夹. 每一层文件夹下的所有 .o 文件被链接成 built-in.o 文件.
这里有一个小的key point就是, 在每一层文件夹下 build 时, obj-y 的值在 Makefile.lib 中被处理为当前文件夹下所有 .o 和子文件夹下的built-in.o

Q2. init/Makefle 中的 mounts-y 是如何被编译到的?
the magic 在 Makefile.lib 中的这句:
# if $(foo-objs) exists, foo.o is a composite object
multi-used-y := $(sort $(foreach m,$(obj-y), $(if $(strip $($(m:.o=-objs)) $($(m:.o=-y))), $(m))))
obj-y 在 init/Makefile中被赋值, 其中有一个是 mounts.o, 但是不存在对应的 mount.c, mounts.o 其实是由$(mounts-y)中的文件一起编译而来, 所以它是一个 composite object
所以 multi-used-y = mounts.o, 因为存在 mounts-y. 所以multi-used = mounts.o, 再经过 addprefix 操作, multi-used-y = init/mounts.o
因为 multi-objs-y := $(foreach m, $(multi-used-y), $($(m:.o=-objs)) $($(m:.o=-y))) , 所以 multi-objs-y = $(mounts-y), 再经过 addprefix 操作, multi-objs-y = init/$(mounts-y)
重点来了, Makefile.build 中有如下代码
$(multi-used-y): FORCE
        $(call if_changed,link_multi-y)
$(call multi_depend, $(multi-used-y), .o, -objs -y) # 重点之一, multi_depend 中使用了 eval 函数, 定义了一条 rule 用来描述 $(multi-used-y) 的依赖关系, 这个rule 由 multi_depend生成, 长这样 $(multi-used-y): 所有依赖的.o 文件
所以, 和上面的 $(multi-used-y): FORCE 是同一个target, 同一个target的 rule会被合并, prerequisite 会被合并, 然后在 变量 link_multi_deps 的 $^ 中, 就是合并后的所有 prerequisites


Q3: make *config 的产物只是 .config 吗？
目前推测：Yes， 如需确认，需要分析 scripts/kconfig/ 下的source code

Q4. make prepare 时候到底都做了什么事情？
列一下, prepare 的 target 依赖关系。
------------------------------------------------------------------
$(vmlinux-dirs): prepare scripts
        $(Q)$(MAKE) $(build)=$@

prepare: prepare0 prepare-objtool

prepare0: archprepare gcc-plugins
         $(Q)$(MAKE) $(build)=.

archprepare: archheaders archscripts prepare1 scripts_basic

# archXXX is defined in arch/$(SRCARCH)/Makefile
archheaders:
         $(Q)$(MAKE) $(build)=arch/x86/entry/syscalls all

# gcc-plugins is defined in scripts/Makefile.gcc-plugins
gcc-plugins: scripts_basic gcc-plugins-check
ifdef CONFIG_GCC_PLUGINS
        $(Q)$(MAKE) $(build)=scripts/gcc-plugins
endif
        @:

scripts_basic:
        $(Q)$(MAKE) $(build)=scripts/basic
        $(Q)rm -f .tmp_quiet_recordmcount

prepare-objtool: $(objtool_target)
------------------------------------------------------------------

根据这些依赖关系，绘制下 flow chart(rule 的执行顺序是深度优先)：
prepare<--|--prepare0<--|--archprepare<--|--archheaders[in arch/x86/Makefile]
          |             |                |        $(Q)$(MAKE) $(build)=arch/x86/entry/syscalls all # 用来生成 arch/x86/include/generated/ 下的头文件
          |             |                |
          |             |                |--archscripts<--scripts_basic[repeat_1]
          |             |                |        $(Q)$(MAKE) $(build)=arch/x86/tools relocs # 显而易见，生成 arch/x86/tools 下的 relocs 工具
          |             |                |
          |             |                |--prepare1<--|--prepare2<--|--prepare3<--|--include/config/kernel.release<--include/config/auto.conf[repeated_2]<--..
          |             |                |             |             | # [Target auto.conf 的处理流程分析在下面]
          |             |                |             |             |
          |             |                |             |             |--prepare-compiler-check # stack protector 相关的check. 略过
          |             |                |             |             |
          |             |                |             |             |--outputmakefile
          |             |                |             |             |[此target/rule只有在使用separate output directory生效]
          |             |                |             |             |
          |             |                |             |             |--asm-generic
          |             |                |             |             |        [long_recipe_0]
          |             |                |             |             |        [long_recipe_1]
          |             |                |             |
          |             |                |             |
          |             |                |             |--$(version_h)<--$(srctree)/Makefile
          |             |                |             |        # version_h = include/generated/uapi/linux/version.h
          |             |                |             |        $(call filechk,version.h)
          |             |                |             |        $(Q)rm -f $(old_version_h)
          |             |                |             |
          |             |                |             |--include/generated/utsrelease.h<--include/config/kernel.release
          |             |                |             |        $(call filechk,utsrelease.h)
          |             |                |             |
          |             |                |             |--include/config/auto.conf[repeat_2]<--|--$(KCONFIG_CONFIG)
          |             |                |             |  [match include/config/%.conf]        |[.config, produced by make *config]
          |             |                |             |                                       |
          |             |                |             |                                       |<--include/config/auto.conf.cmd
          |             |                |             |                                       |[对于clean src tree, 此时此文件还不存在]
          |             |                |             |
          |             |                |             |        $(Q)$(MAKE) -f $(srctree)/Makefile silentoldconfig
          |             |                |             |        [silentoldconfig matches %config, 会创建include/config 和 include/generated目录]
          |             |                |
          |             |                |
          |             |                |        $(Q)mkdir -p $(MODVERDIR) $(if $(KBUILD_MODULES),; rm -f $(MODVERDIR)/*)
          |             |                |        [MODVERDIR只有编译KBUILD_EXTMOD时才有值]
          |             |                |
          |             |                |
          |             |                |
          |             |                |
          |             |                |
          |             |                |--scripts_basic[repeat_1]
          |             |                |        $(Q)$(MAKE) $(build)=scripts/basic # build fixdep & bin2c under scripts/basic
          |             |                |        $(Q)rm -f .tmp_quiet_recordmcount
          |             |
          |             |# defined in arch/x86/Makefile
          |             |ifeq ($(CONFIG_KEXEC_FILE),y)
          |             |        $(Q)$(MAKE) $(build)=arch/x86/purgatory arch/x86/purgatory/kexec-purgatory.c
          |             |endif
          |             |
          |             |
          |             |--gcc-plugins<--|--scripts_basic[repeat_1]
          |             |                |
          |             |                |
          |             |                |--gcc-plugins-check
          |             |                |ifdef CONFIG_GCC_PLUGINS
          |             |                |        $(Q)$(MAKE) $(build)=scripts/gcc-plugins
          |             |                |endif
          |
          |
          |        $(Q)$(MAKE) $(build)=.
          |
          |
          |
          |
          |
          |
          |
          |
          |--prepare-objtool


[long_recipe_0]: $(Q)$(MAKE) -f $(srctree)/scripts/Makefile.asm-generic src=asm obj=arch/$(SRCARCH)/include/generated/asm
[long_recipe_1]: $(Q)$(MAKE) -f $(srctree)/scripts/Makefile.asm-generic src=uapi/asm obj=arch/$(SRCARCH)/include/generated/uapi/asm


Q5. Empty recipes 和 Force target 的关系，区别？


Q6. 目标 silentoldconf 的处理流程?
因为 target include/config/auto.conf match 了下面的 rule

include/config/%.conf: $(KCONFIG_CONFIG) include/config/auto.conf.cmd
         $(Q)$(MAKE) -f $(srctree)/Makefile silentoldconfig

所以, 有必要分析下 silentoldconfig 的处理流程细节.

在 scripts/kconfig/Makefile 中有如下代码:
silentoldconfig: $(obj)/conf
        $(Q)mkdir -p include/config include/generated
        $(Q)test -e include/generated/autoksyms.h || \
            touch   include/generated/autoksyms.h
        $< $(silent) --$@ $(Kconfig)

可以看出, silentoldconfig 依赖于 scripts/kconfig/conf, 下面分析 conf 的生成过程.
conf-objs       := conf.o  zconf.tab.o  # 但其实没有 zconf.tab.c 文件, 需要生成
hostprogs-y := conf nconf mconf kxgettext qconf gconf

$(obj)/zconf.tab.o: $(obj)/zconf.lex.c $(obj)/zconf.hash.c  # prerequisites中的2个 .c 也是不存在的, 也需要生成

target $(obj)/zconf.tab.o match 了 Makefile.build 中的这条最常用的 rule:

$(obj)/%.o: $(src)/%.c $(recordmcount_source) $(objtool_obj) FORCE

说明 $(obj)/zconf.tab.o 也依赖于 $(obj)/zconf.tab.c.  关于target $(obj)/zconf.tab.o 的 两条 rule 合并在一起(合并 prerequisites),
它的 prerequisites 变成了:  $(obj)/zconf.tab.c  $(obj)/zconf.lex.c  $(obj)/zconf.hash.c, 这三个文件并不存在, 所以要找到生成他们的 rule.
在 Makefile.lib 有这么一条 rule, 可以 match 这三个 target 文件:

$(obj)/%: $(src)/%_shipped
        $(call cmd,shipped)

直接用cat转换了下后缀名, shipped 文件变成了 .c 文件.
这里的trick是:  zconf.tab.c 中 include 了很多 .c 文件!!!
#include "zconf.hash.c"
#include "zconf.lex.c"
#include "util.c"
#include "confdata.c"
#include "expr.c"
#include "symbol.c"
#include "menu.c"
所以 这些 .c 文件不会被编译

宗上, silentoldconfig 的实际结果是 /scripts/kconfig/conf --silentoldconfig Kconfig
在代码 scripts/kconfig/conf.c 中有如下comment:
/* silentoldconfig is used during the build so we shall update autoconf.
 * All other commands are only used to generate a config.
 */

Q7. include/config/auto.conf  include/config/auto.conf.cmd 等文件是如何生成的？
这两个以及其他若干文件是在 `make silentoldconfig` 的过程中生成的. 由Q6可知，目标 silentoldconfig 会创建
include/config & include/generated 目录，最终执行的命令是 scripts/kconfig/conf --silentoldconfig Kconfig.
由可执行程序 conf 的 main 函数(conf.c)可以看到， 只有在 silentoldconfig 时， 才会调用函数 conf_write_autoconf，
这个函数就是关键所在了，在此函数中，会生成:
include/config/auto.conf.cmd

include/generated/autoconf.h
include/config/tristate.conf
include/config/auto.conf

每次更新 .config 后去重新 make 时，都会更新上面倒数3个文件。
